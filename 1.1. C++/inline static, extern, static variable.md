헤더 가드는 한 번만 헤더 파일이 포함되도록 보장하지만, inline static 변수는 헤더 파일이 여러 소스 파일에서 포함되면 각 소스 파일에 대해 별도의 인스턴스를 생성합니다. 이는 링크 시간에 중복 정의 오류를 발생시킬 수 있습니다.

즉, inline static으로 지정된 변수는 그것의 헤더를 사용하는 소스 파일 마다 독립적으로 지정된다. 이것은 프로그램 전체에서 사용되는 글로벌 변수에 적용할 경우 각 각 독립된 객체를 가지게 하는 문제를 야기할 수 있다. 따라서 이러한 변수는 extern으로 선언하는게 좋다. extern으로 선언하면 해당 변수는 static과 달리, 외부 변수로 취급되며 여러 소스파일에 해당 헤더파일이 include 되어도 변수를 하나만 생성해준다. 그리고 일반 static은 기본적으로 내부 링크를 제공한다. 이 말이 조금 햇갈리는 이유는 static으로 지정하더라도 외부 소스에서 해당 헤더를 include 하면 그걸 외부 소스에서 사용할 수 있는지 아직은 나도 모르기 때문. 한번 나중에 테스트를 해보고 이와 관련된 내용은 Pro C++의 p.608에도 잘 설명되어 있다.

따라서 결론은 글로벌 변수는 반드시 inline static이 아닌, extern으로 선언해야하며, static과 extern은 서로 배타적 관계에 있는 키워드이다. 반드시 둘 중 하나만을 써야한다는 말이다.

또한 그냥 inline만 사용하는 경우에는 그것이 더 좋다. 이렇게 하면 오히려 단일 정의 규칙(One Definition Rule, ODR)을 준수하게 하도록 해서 이 정의가 모든 소스파일에서 단 한번만 정의되도록 할 수 있기 때문이다. 따라서 inline static만 조심해서 써야한다. 구지 써야한다면 다른 소스파일에서 헤더를 중복으로 사용하는 일이 없어야한다.

또한 클래스 내부에서 inline static을 사용하는 경우에는 위와같이 소스파일마다 독립적인 객체를 생성하는 규칙이 적용되지 않는다. 따라서 클래스 내부에서 inline static을 사용하는 것은 모든 클래스 객체가 공유하는 단 하나의 변수만을 사용하므로 상관이 없다. 

또한 책에서 보면 static을 이용한 내부 링크를 사용하는 것 보다는 익명 namespace를 사용하여 내부 링크를 사용할 것을 권하고 있다. 