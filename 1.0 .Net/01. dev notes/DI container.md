싱글턴으로 객체를 만들어야하는 경우 뿐 아니라 Scoped, transient 단위로도 객체를 알아서 관리해주는 컨테이너다. 예를 들어서 Controller, Searcher, CommandMessenger를 가지고 설명을 해보자면, 이들을 각기 그에 상응하는 interface를 만들고 DI에 AddSingleton을 통해 인터페이스와 구현 클래스를 묶어주면 된다. 물론 구현 클래스는 인터페이스를 상속해야한다. 인터페이스를 구현한다고 생각하면 된다. 이런식으로 할 경우 좋은점은 클래스의 primary constructor를 사용해서 필요한 인터페이스 파라미터를 가지고 그걸 직접 클래스 내부에서 사용할 수 있게된다. 각 클래스들은 이러한 인터페이스들을 통해서 서로의 의존성을 주입하고, 이것을 통해서 여러가지 통신이라던가 콜백, 데이터 참조를 얻는 작업 등을 해낼 수 있다. 

더이상 데이터를 팩토리 패턴을 통해 팩토리에서 생성하지 말자. 이건 올바른 팩토리 패턴이 아닐 뿐더러, 팩토리에 너무 많은 책임을 전가하며, 코드 리팩토링에 매우 어려움이 있다. 각 클래스마다 맡은바가 있을터, 그에 맞는 데이터를 클래스 인스턴스가 소유하게 두고 이것을 속성화해서 각 클래스들은 인터페이스를 통해서 필요한 데이터에 접근할 수 있도록 한다. 이렇게 인터페이스를 primary constructor, DI 컨테이너를 이용하면 싱글턴 관리도 내가 할 필요가 없으며, 각 클래스간 코드 의존도와 결합도를 낮춰준다. 

기존 방식에서는 여러가지 인스턴스들, 데이터 인스턴스들이 복잡하게 얽혀있어서 관리하기도 매우 힘들었다. 클래스 내부에서 인스턴스를 생성하고 그것을 변수로 두어서 그 인스턴스를 다른 클래스에게 팩토리 패턴으로 주입하고.. 이건 뭔가 정말 suck 그 자체인 방식이었다. 이것을 DI 컨테이너를 통해서 완전히 개선해버렸다. 인스턴스에 대한 라이프 사이클, 의존성 주입을 모두 DI 컨테이너가 일임하게 하고, 클래스들끼리 상호작용할때에는 interface를 적극 활용하였다. 또한 데이터 타입의 멤버의 경우에는 property를 활용해서 이것을 interface를 통해 접근할 수 있도록 만들어주었다. 이렇게 하면 각 클래스간 참조를 interface를 통해 하게된다. 더군다나 primary constructor를 사용하면 그 interface를 담는 멤버 변수를 선언할 필요 없이 그 즉시 그 interface의 parameter를 클래스 내부 어느곳에서나 사용할 수 있게 되는 장점. 너무나도 좋은 것이다. 

게다가 의존성 순환 문제를 detact를 정확히 해준다. 이번 프로젝트에서 DI를 통해서 수많은 클래스들이 서로 의존 순환하고 있었다는 사실을 알게됨. 그것도 심각한 수준으로. ㅋㅋ 결국 클래스 구조를 [[the_cave Operator class relationship.canvas|재편]]해야했다. 
그냥 막무가네로 Controller에서 Searcher interface를 갖다쓰고, Searcher에서는 다시 Controller interface를 갖다쓰고.. 이런게 한 두개가 아니었다. ㅋㅋ 
결국 하위 구조를 통해 해결해야했다. Controller -> CommandMsger -> Searcher -> SearcherOpertor 이런식으로 데이터와 컨트롤이 한 방향을 향해서 흘러가게 하는 식이다. 순환이 없이 자연스럽게 흘러나오는 구조. 
이런식으로 클래스를 짜야했다.