시퀀스는 큐로 설계하면 된다. 키가 눌린 순서대로 저장될 것이다. 원래는 시퀀스는 특수한 명령이다. 보통은 press set, release set의 키조합 contains만으로도 키바인딩이 작동해야하지만 시퀀스의 경우에는 미리 지정한 특수한 키가 눌릴때 다른 일부 지정된 키가 차단되어야하며 이렇게 하면 아주 자유로운 키 시퀀스를 입력할 수 있는 상태가 된다. 핵심은 시퀀스를 기록하는 구간은 특수키가 눌리고부터 떼지기 까지라는 것이다. 그때 큐로 따로 시퀀스를 기록해둔다. 예를들어 현재 {s, w, d}가 눌리고 이 중에서 s, d가 미리 정의된 시퀀스 패턴이라면 특수키에 의한 시퀀스 기록에 의해 첫번째 시퀀스가 레코드된다. 그리고 특수키가 떼어졌을때 이 시퀀스 큐와 시퀀스 패턴들을 서로 비교하여 어떤 명령어가 first로 실행되는지를 파악하여 그 명령을 오퍼레이터에 전달하여 실행한다. 명령은 열거형으로 정의할것이며, 패턴 객체와 같이 저장된다. 패턴 객체에는 패턴, 패턴 특성(키바인딩 특성), 액션 enum 등이 저장될 것이다. 만약 시퀀스 입력이라면 패턴 중 시퀀스에 해당되는 리스트만을 가져와서 매칭을 하면 될 것이다. 그리고 이러한 리스트를 저장할때에는 특히 순서가 sort되도록 정렬시키면 더욱 빠르게 매칭이 이루어질 것이다. 왜냐면 일단 첫번째 시퀀스에 해당하는 s를 먼저 찾고, 그 다음에 추려진 목록에서 d를 찾아야하기 때문에 패턴 시퀀스에 대한 정렬이 필수적이다. 패턴은 아마도 최대 3개까지만을 허용할 것이다. 그 이상까지는 필요치 않을 것이며 패턴 첫번째 끼리 먼저 정렬 후, 두번째 끼리, 세번째 끼리 정렬할 것이다. 이렇게 한 뒤, 레코드 큐에서 pop을 할때마다 첫번째 시퀀스 키 값이 있는지를 순회하며 확인하며, 만약 발견되었을 경우 그것이 바로 첫번째 

시퀀스 패턴을 담는 컨테이너를 따로 만들자. 그리고 이제 생각이 난건데, 정렬 순서에 대한 것이다. 예를들어 키 시퀀스 패턴이 3개인 경우에는 그것을 우선적으로 순회하도록 정렬해야한다는 것이다. 그렇지 않을 경우 예를들어 (s, d) 또는 (s, d, e)와 같은 패턴이 있을때 3개의 패턴은 앞의 패턴 매칭에 의헤 무시된다. 그러므로 반드시 패턴의 개수가 많은 3개부터 정렬되도록 한 뒤, 3개짜리 먼저 스캔을 하도록 해야한다. 그 다음에 그 그룹 내에서 첫번째, 두번째, 세번째 순으로 정렬을 해야한다. 이것 역시 여러가지 테스트가 진행 되어야할 것이다. 그리고 다시 패턴을 매칭하는 것에 대해서 따져보자면 구지 첫번째 끼리만 매칭할 필요는 없다는 것이다. 예를들어 입력 시퀀스가 (w,s,a,d)일때 (s,d)를 찾는 것을 생각해보자. 패턴은 그 외에도 여러개가 있다고 가정하자. 일단 레코드 시퀀스에서 어떻게 해야 s,d를 매칭할 수 있을지를 생각해야한다. 기존방법도 유효하기는 하다. 그러나 이것의 문제는 패턴 리스트 순회를 여러번 해야한다는 것이다. 그러지 말고 한번에 순회를 검색하는게 나아보인다. 그렇게 하려면 어떻게 해야할까? 
패턴 매칭, 그리고 순서 이것을 충족하여야한다. 큐를 pop할때 우선 첫번째로 나오는 패턴은 s다. 또한 반드시 가장 먼저 찾아진 패턴의 명령어만 단일로 실행하도록 하여야한다. 아마도 첫번째 방법으로 하는게 나을 수도 있겠다. 우선 첫 패턴이 s인 경우를 전부 가져온 뒤, 그 뒤에는 a가 pop되는데, 이때부터는 첫 패턴이 s인 그룹에서 두번째 패턴이 a인 경우를 찾으면 된다. 또한 만약 패턴이 3개짜리인 경우를 생각해야한다. 만약 (s,d,w)라는 패턴이 있다면 어떨까. 그럴때에는 미리 정렬된 패턴에서 찾도록 해야할 것이다. s를 찾았다. 그 뒤에는 두번째 패턴이 d인것을 찾을 것이다. 왜냐면 두번째 패턴이 a인 경우는 없다고 가정할것이다. 그러면 패턴은 두 가지로 좁혀진다. 글쎄. 이 경우에는 어떻게 할 것인가. 만약 d를 찾았다면 문제는 두 명령어 중에 반드시 (s,d)인것을 실행해야할 것이다. 이 경우에는 말이다. 그러므로 레코드 시퀀스의 전체를 pop해야하할 것이다. 이제 두번째 패턴이 d인 그룹을 가져오면 두 가지 경우 중 하나인데, 이것을 결정해야한다. 그런데 레코드 시퀀스에서는 이제 d 다음은 없다. 그러므로 세번째 패턴을 매칭할 필요는 없는 것이다. 그러면 이때에는 곧바로 (s,d)인 패턴의 명령을 실행하면 될 것이다. 그렇다면 만약 입력 레코드가 어 길어진다면 어떨까? 예를들어 (w,s,a,d,f)를 입력했다고 가정하자. 이 때 d까지는 찾아서 이제 남은 패턴 그룹은 (s,d), (s,d,w) 두가지다. 아직 레코드에는 다음 f가 남아있다. 그럼 이제 여기서 할 일은 세번째 패턴이 f인지를 찾는것이다. 그러나 그런건 없다. 그러므로 (s,d,w)개 아닌 (s,d)가 실행되는 것이다.
만약 입력값이 (w,s,a,d,w)라면 어떨까. 그럴 때에는 우선 맨 처음부터 다시 하면 w가 첫번째인 패턴은 없을 것이니 넘어가고, 이제 두번째인 s를 찾으면 (s,d), (s,d,w)를 포함한 여러 패턴이 그루핑될거다. 물론 패턴 개수가 많은것이 우선적으로 정렬된다. 그 다음 a를 두번째 패턴으로 가지는 패턴은 없다고 가정하면 아직 두번째 패턴을 찾지 못했다. 그 다음에는 d를 두번째 패턴으로 갖는 패턴들을 그루핑한다. 그러면 다시 두가지가 남는다. 레코드는 아직 w가 남아있으므로 마지막으로 세번째 패턴인 w를 가지는 패턴을 찾고 만약 그게 있으면 실행한다. 그러면 마침내 (s,d,w) 패턴의 명령이 실행되는 것이다. 패턴 리스트는 이러한 그루핑과 엘리먼트 개수에 따른 정렬, 그리고 그 하위 정렬들로 각 엘리먼트들의 첫번째, 두번째, 세번째에 따른 하위 정렬을 구현할 수 있는 자료구조로 구현되어야할 것이다. 만약 패턴이 하나라면 어떨까? 이럴때에도 문제가 생긴다. 시퀀스 패턴은 우선적으로 패턴 수가 가장 많은 패턴부터 검색되도록 수행되어야할 것이다. 그리고 그런 많은 수의 패턴이 검색되지 않으면 그 수에서 -1하는 식으로 패턴을 검색해야한다. 그래야만 의도대로 프로그램이 동작할 것이다. 그래. 예륻들어 레코드 패턴이 (w,a,d,s)라고 해보자. 그러면 역시 세번째 패턴이 인출될때까지 별다른 패턴을 그루핑하지 않았을 것이다. 그런데 마지막에 s가 인출되면 이때에는 역시 첫번째 패턴이 s인 그룹들을 그루핑할 것이다. 그리고 만약 여기에서 인출이 모두 완료되면 인출된 패턴중 매칭되는 패턴의 수는 1이므로 패턴 수가 1인 (s)가 실행되도록 하는 것이다. 여기에서 중요한 점이 하나 발견되는데, 그것은 매칭된 패턴의 번째 수다. 
그런데 또다른 케이스는 레코드 패턴에서 두 가지 이상의 패턴이 발견되는 경우도 있다는 것이다. 이런 것을 피하기위해서는 반드시 시퀀스에 가장 먼저 기록된 패턴만을 매칭하여 실행되어야한다는 것이다. 