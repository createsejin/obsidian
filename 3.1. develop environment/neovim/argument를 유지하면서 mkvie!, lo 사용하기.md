folding이 많이 필요한 파일이 있는 경우가 있다. 문제는 이럴 경우에 `lo`나 `so`를 통해서 view vim script를 불러오면 그 안에 포함된 argument가 그때 저장해놨던 시점 기준으로 다시 로딩되어서 기존 argument가 사라질 위험이 있다는 것이다. 예를들어서 3개의 탭에 각각의 local argument list를 운용하고, 이 세 개의 argument list에 동일한 file 하나가 존재한다고 가정하자. 이 파일의 이름을 `arch_back.sh`라고 가정하자. 그리고 각각의 argument list는 서로 다르다. 이럴 경우에 각각의 탭에서 `arch_back.sh`에서 적절히 필요한 폴딩을 만들어준다. 그 후 저장할때 각각의 탭마다 `mkvie!1`, `mkvie!2`, `mkvie!3` 이런식으로 저장해두는것이다. 이렇게 하면 자동으로 `~/.local/state/nvim/view/` directory에 각각의 숫자가 넘버링된 view vim script가 저장된다. 이렇게 하면 각각의 탭의 독립된 argument마다 해당 파일의 폴딩 상태를 제대로 보존할 수 있다. 그러면서 각각의 argument 역시 보존된다. 
  다시 로딩할때는 역시 번호를 이용한다. 각각의 탭마다 `lo1`, `lo2`, `lo3` 이런식으로 불러오는 것이다.
주의할점은 `lo`명령으로 인해 그 이전의 argument가 날라갈 수 있다는 것이다. 아마도 argument를 저장하는 가장 효율적인 방식은 session vim script를 이용하는 것이다. `lo`를 쓰기 전에 그 이전에 반드시 `mkvie! 3`같은 명령어를 이 argument list에 대해서 수행했는지를 확신할때에만 `lo`를 사용하는게 좋다.

또한 앞서 말했듯이 session을 사용해야하는데, 되도록이면 수동 저장 방식의 session을 활용하는게 좋다. 왜냐하면 이렇게 해야만 이전 저장 세션으로 세션을 복원할 수 있기 때문이다. 만약 Obsession처럼 모든 변경사항마다 자동으로 세션이 저장되게 하면 좋은데 문제는 문제가 발생했을때 세션을 복원할 방법이 좀처럼 쉽지 않다는 것이다. 예를 들어서 실수로 tab을 닫는다던가 argument가 소속된 윈도우를 아예 없애버리는 경우가 생길 수 있다. 이런 경우를 복원하려면 수동으로 세션을 저장하고 세션의 변경사항을 저장할 필요가 있을때에만 세션을 수동으로, `mks! session_name.vim`를 이용해서 저장하는게 낫다는 것이다. ^1

Global인 경우에는 lo를 쓰자. 
대신 이것은 하나의 work space에서 유효한 방법이다.
같은 파일을 서로 다른 세션에서 열면 argument conflict가 발생할 수 있다. 따라서 lo는 신중히 사용해야한다.